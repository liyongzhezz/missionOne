(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{414:function(t,s,a){t.exports=a.p+"assets/img/pod-stop-timeline.1fac6e5a.jpeg"},415:function(t,s,a){t.exports=a.p+"assets/img/pod-stop-timeline-good.a62a6322.jpeg"},428:function(t,s,a){"use strict";a.r(s);var e=a(2),r=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("p",[t._v("在pod生命周期中会因为各种问题，尤其是发布变更导致重启，这种时候如果不够优雅，则会造成业务有损")])]),s("h2",{attrs:{id:"pod停止过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pod停止过程"}},[t._v("#")]),t._v(" pod停止过程")]),t._v(" "),s("p",[t._v("pod停止过程分为两个时间线，apiserver会去更新pod网络规则及发送终止信号到容器：")]),t._v(" "),s("p",[s("img",{attrs:{src:a(414),alt:"pod停止时间线"}})]),t._v(" "),s("h3",{attrs:{id:"更新网络规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更新网络规则"}},[t._v("#")]),t._v(" 更新网络规则")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("kube-apiserver 接收到 pod 删除请求，将 pod 在 Etcd 中的状态更新为 Terminating；")])]),t._v(" "),s("li",[s("p",[t._v("Endpoint Controller 从 Endpoint 对象中删除 pod 的 IP；")])]),t._v(" "),s("li",[s("p",[t._v("kuber-proxy 根据 Endpoint 对象的变化更新 iptables 的规则，不再将流量路由到被删除的 Pod；")])])]),t._v(" "),s("h3",{attrs:{id:"删除pod"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#删除pod"}},[t._v("#")]),t._v(" 删除pod")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("kube-apiserver 接收到 Pod 删除请求，将 Pod 的再 Etcd 中的状态更新为 Terminating；")])]),t._v(" "),s("li",[s("p",[t._v("Kubelet 在节点清理容器相关资源，如存储、网络；")])]),t._v(" "),s("li",[s("p",[t._v("Kubelet 向容器发送 SIGTERM；如果容器内的进程没有配置，容器将立即退出。")])]),t._v(" "),s("li",[s("p",[t._v("如果容器在默认的 30 秒内没有退出，Kubelet 将发送 SIGKILL 并强制它退出。")])])]),t._v(" "),s("p",[s("strong",[t._v("由于两个时间线是并行的，所以无法保证一定在删除pod前更新掉网络规则，会导致部分请求可能路由到已经删除的pod，造成访问异常")])]),t._v(" "),s("h2",{attrs:{id:"配置优雅停止"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置优雅停止"}},[t._v("#")]),t._v(" 配置优雅停止")]),t._v(" "),s("h3",{attrs:{id:"进程设置优雅关闭"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程设置优雅关闭"}},[t._v("#")]),t._v(" 进程设置优雅关闭")]),t._v(" "),s("p",[t._v("以 SpringBoot 为例，启用优雅关闭可以 Spring Boot 配置文件中添加下面设置：")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("server")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("shutdown")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" graceful\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spring")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("lifecycle")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n         "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("timeout-per-shutdown-phase")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 30s\n")])])]),s("p",[t._v("通过使用上述配置，Spring Boot 保证在收到 SIGTERM 后不再接受新请求，并在超时内完成所有正在进行的请求的处理。即使无法及时完成，也会记录相关信息，然后强制退出。")]),t._v(" "),s("blockquote",[s("p",[t._v("对于 timeout 的值，根据经验除特殊情况外所有请求通常在 30 秒内完成处理。对于未在定义的超时时间内完成的，我们将在日志监控中捕获超时并发送警报，然后解决超时的根本原因并采取相应的措施")])]),t._v(" "),s("h3",{attrs:{id:"添加-prestophook"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#添加-prestophook"}},[t._v("#")]),t._v(" 添加 preStopHook")]),t._v(" "),s("p",[t._v("为了保证不再将新流量路由到该 pod 后开始删除该 pod。因此，应该将 preStopHook 添加到 Kubernetes yaml 文件中，让 Kubelet 在收到删除 pod 事件时等待一段时间，在开始删除 pod 之前留出足够的时间来更新网络规则。")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("lifecycle")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("preStop")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("command")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sh"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"-c"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sleep 10"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("  \n")])])]),s("h3",{attrs:{id:"修改graceperiodseconds"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#修改graceperiodseconds"}},[t._v("#")]),t._v(" 修改GracePeriodSeconds")]),t._v(" "),s("p",[t._v("经过前2步的配置Kubernetes 为容器删除留下了 30 秒的最大时间尺度。如果 Spring 的优雅关闭超时时间和 Kubernetes 的 preStopHooks 之和超过 30 秒，可能会导致 Kubernetes 在 Spring Boot 处理完请求之前强行删除容器。")]),t._v(" "),s("p",[t._v("因此，如果过程超过 30 秒，则应将 timerminationGracePeriodSeconds 调整为超出 Spring 加 preStopHook 的优雅关闭超时。")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("terminationGracePeriodSeconds")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("45")]),t._v("\n")])])]),s("h2",{attrs:{id:"优雅退出时间线"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优雅退出时间线"}},[t._v("#")]),t._v(" 优雅退出时间线")]),t._v(" "),s("p",[s("img",{attrs:{src:a(415),alt:"优雅退出时间线"}})])])}),[],!1,null,null,null);s.default=r.exports}}]);