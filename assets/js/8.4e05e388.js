(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{404:function(a,s,e){a.exports=e.p+"assets/img/docker-bridge.aec5bc07.png"},405:function(a,s,e){a.exports=e.p+"assets/img/cni-type.e3888afe.jpg"},406:function(a,s,e){a.exports=e.p+"assets/img/flannel-host-gw.a8414275.png"},407:function(a,s,e){a.exports=e.p+"assets/img/calico-bgp.88d98b75.png"},408:function(a,s,e){a.exports=e.p+"assets/img/calico-ipip.5e2f4649.png"},423:function(a,s,e){"use strict";e.r(s);var t=e(2),r=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("p",[a._v("Kubernetes本身并没有自己实现容器网络而是通过插件化的方式自由接入，需要满足如下基本原则：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("pod 无论运行在任何节点都可以互相直接通信，而不需要借助 NAT 地址转换实现。")])]),a._v(" "),s("li",[s("p",[a._v("node 与 pod 可以互相通信，在不限制的前提下，pod 可以访问任意网络。")])]),a._v(" "),s("li",[s("p",[a._v("pod 拥有独立的网络栈，pod 看到自己的地址和外部看见的地址应该是一样的，并且同个 pod 内所有的容器共享同个网络栈。")])])])]),s("h2",{attrs:{id:"容器网络"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器网络"}},[a._v("#")]),a._v(" 容器网络")]),a._v(" "),s("h3",{attrs:{id:"容器网络要素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器网络要素"}},[a._v("#")]),a._v(" 容器网络要素")]),a._v(" "),s("p",[a._v("一个 Linux 容器的网络栈是被隔离在它自己的 "),s("code",[a._v("Network Namespace")]),a._v("中，"),s("code",[a._v("Network Namespace")]),a._v(" 包括了：")]),a._v(" "),s("ul",[s("li",[a._v("网卡（Network Interface）；")]),a._v(" "),s("li",[a._v("回环设备（Lookback Device）；")]),a._v(" "),s("li",[a._v("路由表（Routing Table）；")]),a._v(" "),s("li",[a._v("iptables 规则；")])]),a._v(" "),s("h3",{attrs:{id:"同宿主机容器通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同宿主机容器通信"}},[a._v("#")]),a._v(" 同宿主机容器通信")]),a._v(" "),s("p",[a._v("如果要多台主机通信，我们通过交换机就可以实现彼此互通，在 Linux 中，我们可以通过网桥来转发数据。")]),a._v(" "),s("p",[a._v("在容器中，以上的实现是通过 "),s("code",[a._v("docker0")]),a._v(" 网桥，凡是连接到 "),s("code",[a._v("docker0")]),a._v(" 的容器，就可以通过它来进行通信。要想容器能够连接到 "),s("code",[a._v("docker0")]),a._v(" 网桥，我们也需要类似网线的虚拟设备"),s("code",[a._v("Veth Pair")]),a._v(" 来把容器连接到网桥上。")]),a._v(" "),s("blockquote",[s("p",[a._v("Veth Pair：Veth设备对的引入是为了实现在不同网络命名空间的通信,总是以两张虚拟网卡（veth peer）的形式成对出现的。并且，从其中一端发出的数据，总是能在另外一端收到")])]),a._v(" "),s("h3",{attrs:{id:"实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实践"}},[a._v("#")]),a._v(" 实践")]),a._v(" "),s("p",[a._v("首先启动一个容器：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[a._v("docker")]),a._v(" run "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-d")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--name")]),a._v(" c1 alpine:v3.8 /bin/sh\n")])])]),s("p",[a._v("容器启动后可以看到容器中的网络配置：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[a._v("docker")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("exec")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-it")]),a._v(" c1  /bin/sh \n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# ifconfig")]),a._v("\neth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02\n          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:14 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:0\n          RX bytes:1172 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1.1")]),a._v(" KiB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  TX bytes:0 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),a._v(" B"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\nlo        Link encap:Local Loopback\n          inet addr:127.0.0.1  Mask:255.0.0.0\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000\n          RX bytes:0 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),a._v(" B"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  TX bytes:0 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),a._v(" B"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# route -n")]),a._v("\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),a._v(".0.0         "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.1      "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),a._v(".0.0         UG    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("      "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("        "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" eth0\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.0      "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),a._v(".0.0         "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("255.255")]),a._v(".0.0     U     "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("      "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("        "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" eth0\n")])])]),s("p",[a._v("可以看到其中有一张 "),s("code",[a._v("eth0")]),a._v(" 的网卡，它就是 "),s("code",[a._v("veth peer")]),a._v(" 其中的一端的虚拟网卡。然后通过 "),s("code",[a._v("route -n")]),a._v(" 查看容器中的路由表，eth0 也正是默认路由出口。所有对172.17.0.0/16 网段的请求都会从 eth0 出去。")]),a._v(" "),s("p",[a._v("再在宿主机上查看 "),s("code",[a._v("Veth peer")]),a._v(" 的另一端：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[a._v("ifconfig")]),a._v("\ndocker0: "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("flags")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("416")]),s("span",{pre:!0,attrs:{class:"token operator"}},[s("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[a._v("3")]),a._v("<")]),a._v("UP,BROADCAST,RUNNING,MULTICAST"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("  mtu "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1500")]),a._v("\n        inet "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.1  netmask "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("255.255")]),a._v(".0.0  broadcast "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".255.255\n        inet6 fe80::42:6aff:fe46:93d2  prefixlen "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("64")]),a._v("  scopeid 0x2"),s("span",{pre:!0,attrs:{class:"token operator"}},[s("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[a._v("0")]),a._v("<")]),a._v("link"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n        ether 02:42:6a:46:93:d2  txqueuelen "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("Ethernet"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        RX packets "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  bytes "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),a._v(" B"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        RX errors "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  dropped "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  overruns "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  frame "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\n        TX packets "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("8")]),a._v("  bytes "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("656")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("656.0")]),a._v(" B"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        TX errors "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  dropped "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" overruns "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  carrier "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  collisions "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\n\neth0: "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v(".\n\nlo: "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v(".\n\nveth20b3dac: "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("flags")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("416")]),s("span",{pre:!0,attrs:{class:"token operator"}},[s("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[a._v("3")]),a._v("<")]),a._v("UP,BROADCAST,RUNNING,MULTICAST"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("  mtu "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1500")]),a._v("\n        inet6 fe80::30e2:9cff:fe45:329  prefixlen "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("64")]),a._v("  scopeid 0x2"),s("span",{pre:!0,attrs:{class:"token operator"}},[s("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[a._v("0")]),a._v("<")]),a._v("link"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n        ether "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("32")]),a._v(":e2:9c:45:03:29  txqueuelen "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("Ethernet"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        RX packets "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  bytes "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),a._v(" B"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        RX errors "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  dropped "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  overruns "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  frame "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\n        TX packets "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("8")]),a._v("  bytes "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("656")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("656.0")]),a._v(" B"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        TX errors "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  dropped "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" overruns "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  carrier "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("  collisions "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\n")])])]),s("p",[a._v("容器对应的 "),s("code",[a._v("Veth peer")]),a._v(" 另一端是宿主机上的一块虚拟网卡叫"),s("code",[a._v("veth20b3dac")]),a._v("，并且可以通过 brctl 查看网桥信息看到这张网卡是在 docker0 上。")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("brctl show\n\ndocker0        "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("8000")]),a._v(".02426a4693d2    no        veth20b3dac\n")])])]),s("p",[a._v("然后我们再启动一个容器，从第一个容器是能 ping 通第二个容器：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[a._v("docker")]),a._v(" run "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-d")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--name")]),a._v(" c2 "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-it")]),a._v(" alpine:v3.8 /bin/sh\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("docker")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("exec")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-it")]),a._v(" c1 /bin/sh\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# ping 172.17.0.3")]),a._v("\nPING "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.3 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.3"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(": "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("56")]),a._v(" data bytes\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("64")]),a._v(" bytes from "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.3: "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("seq")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("ttl")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("64")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("time")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.291")]),a._v(" ms\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("64")]),a._v(" bytes from "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.3: "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("seq")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("ttl")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("64")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("time")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.129")]),a._v(" ms\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("64")]),a._v(" bytes from "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.3: "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("seq")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("ttl")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("64")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("time")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.142")]),a._v(" ms\n")])])]),s("p",[a._v("其原理就是我们 ping 目标 "),s("code",[a._v("IP 172.17.0.3")]),a._v("时，会匹配到我们的路由表第二条规则，网关为0.0.0.0，"),s("strong",[a._v("这就意味着是一条直连路由，通过二层转发到目的地。")]),a._v(" 要通过二层网络到达"),s("code",[a._v("172.17.0.3")]),a._v("，我们需要知道它的 Mac 地址，此时就需要第一个容器发送一个ARP广播，来通过IP地址查找Mac。此时 "),s("code",[a._v("Veth peer")]),a._v(" 另外一段是 "),s("code",[a._v("docker0")]),a._v(" 网桥，它会广播到所有连接它的 "),s("code",[a._v("veth peer")]),a._v(" 虚拟网卡去，然后正确的虚拟网卡收到后会响应这个ARP报文，然后网桥再回给第一个容器。")]),a._v(" "),s("p",[s("img",{attrs:{src:e(404),alt:"docker bridge"}})]),a._v(" "),s("h2",{attrs:{id:"cni-跨主机通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cni-跨主机通信"}},[a._v("#")]),a._v(" CNI--跨主机通信")]),a._v(" "),s("p",[a._v("docker默认配置下无法实现跨主机通信，K8s为了更好的控制网络的接入并解决这个问题，推出了 "),s("code",[a._v("CNI")]),a._v(" 即"),s("strong",[a._v("容器网络的 API 接口")]),a._v("。")]),a._v(" "),s("h3",{attrs:{id:"什么是cni"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是cni"}},[a._v("#")]),a._v(" 什么是CNI")]),a._v(" "),s("p",[a._v("它是 K8s 中标准的一个调用网络实现的接口，kubelet通过这个API来调用不同的网络插件以实现不同的网络配置，实现了这个接口的就是"),s("code",[a._v("CNI插件")]),a._v("，它实现了一系列的"),s("code",[a._v("CNI API")]),a._v("接口。常见的CNI差劲啊有：flannel、calico、weave、contiv等等。")]),a._v(" "),s("p",[a._v("实际上 CNI 的容器网络通信流程跟前面的基础网络一样，只是CNI维护了一个单独的网桥来代替 "),s("code",[a._v("docker0")]),a._v("。这个网桥的名字就叫作："),s("code",[a._v("CNI 网桥")]),a._v("，它在宿主机上的设备名称默认是："),s("code",[a._v("cni0")]),a._v("。")]),a._v(" "),s("p",[a._v("cni的设计思想，就是：Kubernetes 在启动 "),s("code",[a._v("Infra")]),a._v(" 容器之后，就可以直接调用 CNI 网络插件，为这个 "),s("code",[a._v("Infra")]),a._v(" 容器的 "),s("code",[a._v("Network Namespace")]),a._v("配置符合预期的网络栈。")]),a._v(" "),s("h3",{attrs:{id:"cni网络模式实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cni网络模式实现"}},[a._v("#")]),a._v(" CNI网络模式实现")]),a._v(" "),s("p",[a._v("CNI 插件三种网络实现模式：\n"),s("img",{attrs:{src:e(405),alt:"cnitype"}})]),a._v(" "),s("ul",[s("li",[s("p",[a._v("overlay 模式是基于隧道技术实现的，整个容器网络和主机网络独立，容器之间跨主机通信时将整个容器网络封装到底层网络中，然后到达目标机器后再解封装传递到目标容器。不依赖与底层网络的实现。实现的插件有flannel（UDP、vxlan）、calico（IPIP）等等")])]),a._v(" "),s("li",[s("p",[a._v("三层路由模式中容器和主机也属于不同的网段，他们容器互通主要是基于路由表打通，无需在主机之间建立隧道封包。但是限制条件必须依赖大二层同个局域网内。实现的插件有flannel（host-gw）、calico（BGP）等等")])]),a._v(" "),s("li",[s("p",[a._v("underlay网络是底层网络，负责互联互通。容器网络和主机网络依然分属不同的网段，但是彼此处于同一层网络，处于相同的地位。整个网络三层互通，没有大二层的限制，但是需要强依赖底层网络的实现支持.实现的插件有calico（BGP）等等")])])]),a._v(" "),s("h2",{attrs:{id:"flannel插件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flannel插件"}},[a._v("#")]),a._v(" flannel插件")]),a._v(" "),s("h3",{attrs:{id:"flannel-host-gw模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flannel-host-gw模式"}},[a._v("#")]),a._v(" flannel host-gw模式")]),a._v(" "),s("p",[s("code",[a._v("flannel host-gw")]),a._v(" 是三层路由模式的一种实现，逻辑如下：")]),a._v(" "),s("p",[s("img",{attrs:{src:e(406),alt:"flannel host-gw"}})]),a._v(" "),s("ol",[s("li",[s("p",[s("code",[a._v("node1")]),a._v("上"),s("code",[a._v("container-1")]),a._v(" 要发数据给 "),s("code",[a._v("node2")]),a._v(" 上的 "),s("code",[a._v("container2")]),a._v(" 时，会匹配到如下的路由表规则：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10.244")]),a._v(".1.0/24 via "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10.168")]),a._v(".0.3 dev eth0\n")])])]),s("p",[a._v("表示前往目标网段 "),s("code",[a._v("10.244.1.0/24")]),a._v(" 的 IP 包，需要经过本机 "),s("code",[a._v("eth0")]),a._v(" 出去发往的下一跳ip地址为"),s("code",[a._v("10.168.0.3（node2）")]),a._v("；")])]),a._v(" "),s("li",[s("p",[a._v("数据包到达 "),s("code",[a._v("10.168.0.3")]),a._v(" 以后再通过路由表转发 "),s("code",[a._v("cni")]),a._v(" 网桥，进而进入到 "),s("code",[a._v("container2")]),a._v("。")])])]),a._v(" "),s("p",[a._v("以上可以看到 host-gw 工作原理就是在每个 node 节点都需要配置到每个 pod 网段的下一跳为pod网段所在的 node 节点 IP，pod 网段和 node 节点 ip 的映射关系，flannel 保存在etcd中，flannel 只需要 watch 这些数据的变化来动态更新路由表即可。")]),a._v(" "),s("p",[s("strong",[a._v("优势：")])]),a._v(" "),s("ul",[s("li",[a._v("避免了额外的封包和解包带来的网络性能损耗；")])]),a._v(" "),s("p",[s("strong",[a._v("缺点：")])]),a._v(" "),s("ul",[s("li",[a._v("容器ip包通过下一跳出去时，必须要二层通信封装成数据帧发送到下一跳。如果不在同个二层局域网，那么就要交给三层网关，而此时网关是不知道目标容器网络的（也可以静态在每个网关配置pod网段路由）。所以 "),s("strong",[s("code",[a._v("flannel host-gw")]),a._v(" 必须要求集群宿主机是二层互通的。")])])]),a._v(" "),s("h2",{attrs:{id:"calico插件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#calico插件"}},[a._v("#")]),a._v(" calico插件")]),a._v(" "),s("h3",{attrs:{id:"calico组成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#calico组成"}},[a._v("#")]),a._v(" calico组成")]),a._v(" "),s("p",[a._v("calico 主要由三个部分组成：")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("calico cni插件")]),a._v(": 主要负责与kubernetes对接，供kubelet调用使用；")]),a._v(" "),s("li",[s("code",[a._v("felix")]),a._v(": 负责维护宿主机上的路由规则、FIB转发信息库等；")]),a._v(" "),s("li",[s("code",[a._v("BIRD")]),a._v(": 负责分发路由规则，类似路由器；")]),a._v(" "),s("li",[s("code",[a._v("confd")]),a._v(": 配置管理组件；")])]),a._v(" "),s("h3",{attrs:{id:"calico-bgp模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#calico-bgp模式"}},[a._v("#")]),a._v(" calico BGP模式")]),a._v(" "),s("p",[a._v("calico BGP 大三层网络模式与flannel 提供的类似，也会在每台宿主机添加如下格式的路由规则：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("目标容器IP网段"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" via "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("网关的IP地址"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" dev eth0\n")])])]),s("p",[a._v("其中网关的 IP 地址不通场景有不同的意思：")]),a._v(" "),s("ul",[s("li",[a._v("如果宿主机是二层可达那么就是目的容器所在的宿主机的 IP 地址;")]),a._v(" "),s("li",[a._v("如果是三层不同局域网那么就是本机宿主机的网关IP（交换机或者路由器地址）;")])]),a._v(" "),s("p",[a._v("不同于 flannel 通过 etcd 存储的数据来维护本机路由信息的做法，calico是通过"),s("strong",[a._v("BGP动态路由协议")]),a._v("来分发整个集群路由信息。")]),a._v(" "),s("blockquote",[s("p",[a._v("BGP：Border Gateway Protocol边界网关协议，linxu原生支持的、专门用于在大规模数据中心为不同的自治系统之间传递路由信息。")])]),a._v(" "),s("p",[s("img",{attrs:{src:e(407),alt:"calico bgp"}})]),a._v(" "),s("p",[a._v("calico为每个容器设置一个 "),s("code",[a._v("veth pair")]),a._v(" 设备，然后把另一端接入到宿主机网络空间，由于没有网桥，cni 插件还需要在宿主机上为每个容器的 "),s("code",[a._v("veth pair")]),a._v("设备配置一条路由规则，用于接收传入的IP包，路由规则如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("10.92.77.163 dev cali93a8a799fe1 scope link\n")])])]),s("blockquote",[s("p",[a._v("以上表示发送"),s("code",[a._v("10.92.77.163")]),a._v("的IP包应该发给"),s("code",[a._v("cali93a8a799fe1")]),a._v("设备，然后到达另外一段容器中。")])]),a._v(" "),s("p",[a._v("这样容器发出的IP包就会通过"),s("code",[a._v("veth pair")]),a._v("设备到达宿主机，然后宿主机根据路有规则的下一条地址，发送给正确的网关"),s("code",[a._v("(10.100.1.3)")]),a._v("，然后到达目标宿主机，在到达目标容器。")]),a._v(" "),s("p",[a._v("这些路由规则都是"),s("code",[a._v("felix")]),a._v("维护配置的，而路由信息则是"),s("code",[a._v("calico bird")]),a._v("组件基于"),s("code",[a._v("BGP")]),a._v("分发而来。calico实际上是将集群里所有的节点都当做边界路由器来处理,他们一起组成了一个全互联的网络，彼此之间通过BGP交换路由，这些节点我们叫做"),s("code",[a._v("BGP Peer")]),a._v("。")]),a._v(" "),s("blockquote",[s("p",[a._v("需要注意的是calico 维护网络的默认模式是 "),s("code",[a._v("node-to-node mesh")]),a._v(" ,这种模式下，每台宿主机的BGP client都会跟集群所有的节点BGP client进行通信交换路由。这样一来，随着节点规模数量N的增加，连接会以N的2次方增长，会集群网络本身带来巨大压力。所以一般这种模式推荐的集群规模在50节点左右,超过50节点推荐使用另外一种"),s("code",[a._v("RR（Router Reflector）模式")]),a._v("；")])]),a._v(" "),s("h3",{attrs:{id:"calico-ipip模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#calico-ipip模式"}},[a._v("#")]),a._v(" calico IPIP模式")]),a._v(" "),s("p",[a._v("为了解决"),s("code",[a._v("flannel host-gw")]),a._v("二层互通的限制性，"),s("code",[a._v("calico IPIP")]),a._v("提供的网络方案就可以更好的实现；")]),a._v(" "),s("p",[a._v("当我们有两台宿主机，一台是"),s("code",[a._v("10.100.0.2/24")]),a._v("，节点上容器网络是"),s("code",[a._v("10.92.204.0/24")]),a._v(";另外一台是"),s("code",[a._v("10.100.1.2/24")]),a._v(",节点上容器网络是"),s("code",[a._v("10.92.203.0/24")]),a._v(",此时两台机器因为不在同个二层所以需要三层路由通信，这时calico就会在节点上生成如下路由表：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10.92")]),a._v(".203.0/23 via "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10.100")]),a._v(".1.2 dev eth0 proto bird\n")])])]),s("p",[a._v("这时候因为"),s("code",[a._v("10.100.1.2")]),a._v("跟我们"),s("code",[a._v("10.100.0.2")]),a._v("不在同个子网，是不能二层通信的。这之后就需要使用"),s("code",[a._v("Calico IPIP")]),a._v("模式，当宿主机不在同个二层网络时就是用overlay网络封装以后再发出去。如下图所示：")]),a._v(" "),s("p",[s("img",{attrs:{src:e(408),alt:"calico ipip"}})]),a._v(" "),s("p",[a._v("IPIP模式下在非二层通信时，calico 会在node节点添加如下路由规则:")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10.92")]),a._v(".203.0/24 via "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10.100")]),a._v(".1.2 dev tunnel0\n")])])]),s("p",[a._v("可以看到尽管下一跳任然是node的IP地址，但是出口设备却是"),s("code",[a._v("tunnel0")]),a._v("，其是一个IP隧道设备，主要由Linux内核的IPIP驱动实现，会将容器的ip包直接封装宿主机网络的IP包中，这样到达node2以后再经过IPIP驱动拆包拿到原始容器IP包，然后通过路由规则发送给"),s("code",[a._v("veth pair")]),a._v("设备到达目标容器。")]),a._v(" "),s("p",[a._v("以上仍然会因为封包和解包导致性能下降。如果calico 能够让宿主机之间的router设备也学习到容器路由规则，这样就可以直接三层通信了。比如在路由器添加如下的路由表：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10.92")]),a._v(".203.0/24 via "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10.100")]),a._v(".1.2 dev interface1\n")])])]),s("p",[a._v("而node1添加如下的路由表:")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10.92")]),a._v(".203.0/24 via "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10.100")]),a._v(".1.1 dev tunnel0\n")])])]),s("p",[a._v("那么node1上的容器发出的IP包，基于本地路由表发送给"),s("code",[a._v("10.100.1.1")]),a._v("网关路由器，然后路由器收到IP包查看目的IP，通过本地路由表找到下一跳地址发送到node2，最终到达目的容器。这种方案，我们是可以基于underlay 网络来实现，只要底层支持BGP网络，可以和我们RR节点建立EBGP关系来交换集群内的路由信息。")])])}),[],!1,null,null,null);s.default=r.exports}}]);