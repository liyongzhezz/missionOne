---
title: 滑动窗口算法
author: missionOne
date: '2022-11-27'
categories:
    - 算法
tags:
    - 算法
---

:::tip
滑动窗口算法是在给定特定窗口大小，也可以是动态可变窗口大小的数组或者字符串上进行操作的算法。算法主要的用途就是在于将嵌套循环时间复杂度的效率优化成为线性时间复杂度。简而言之，滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。
:::


## 算法框架
```python
class Solution:
    def problemName(self, s: str) -> int:
        # Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)
        x, y = ..., ...

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(s)):
            # Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)
            x = new_x
            if condition:
                y = new_y

            '''
            ------------- 下面是两种情况，读者请根据题意二选1 -------------
            '''
            # Step 4 - 情况1
            # 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否达到了限定长度 
            # 如果达到了，窗口左指针前移一个单位，从而保证下一次右指针右移时，窗口长度保持不变, 
            # 左指针移动之前, 先更新Step 1定义的(部分或所有)维护变量 
            if 窗口长度达到了限定长度:
                # 更新 (部分或所有) 维护变量 
                # 窗口左指针前移一个单位保证下一次右指针右移时窗口长度保持不变

            # Step 4 - 情况2
            # 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 
            while 不合法:
                # 更新 (部分或所有) 维护变量 
                # 不断移动窗口左指针直到窗口再次合法

        # Step 5: 返回答案
        return ...
```

> 来源：[leetcode](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x/)


## 实例一、求子数组最大平均数
### 题目
一个由 n 个元素组成的整数数组 nums 和一个整数 k，请找出平均数最大且长度为k的连续子数组，并输出该最大平均数。任何误差小于 $10^-5$ 的答案都将被视为正确答案。

> 输入：nums = [1, 12, -5, -6, 50, 3], k = 4
> 
> 
> 输出：12.75
> 
> 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75

> 输入：nums = [5], k = 1
>
> 输出：5.00000

### 解题
```python
import math


class Solution:
    def problem(self, nums: List[int], k: int) -> float:
        # 第一步：首先定义需要维护的变量，平均值最大即求和值最大，因为可能存在负数所以定义初始值为负无穷 
        sum_, max_avg = 0, -math.inf

        # 第二步: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(nums)):
            # 第三步: 更新需要维护的变量 (sum_, max_avg), 不断把当前值积累到sum_上
            sum_ += nums[end]
            if end - start + 1 == k:
                max_avg = max(max_avg, sum_ / k)

            # 第四步：窗口首指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (sum_)
            if end >= k - 1:
                sum_ -= nums[start]
                start += 1
        # 第五步: 返回答案
        return max_avg
```

## 实例二、无重复字符串最长子串
### 题目
给定一个字符串 s, 找出其中不含有重复字符的最长子串的长度。

> 输入: s = "abcabcbb"
>
> 输出: 3 
>
> 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

> 输入: s = "bbbbb"
> 
> 输出: 1
> 
> 因为无重复字符的最长子串是 "b"，所以其长度为 1。

### 解题
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # Step 1: 定义需要维护的变量, 本题求最大长度，所以需要定义max_len, 该题又涉及去重，因此还需要一个哈希表
        max_len, hashmap = 0, {}

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(s)):
            # Step 3
            # 更新需要维护的变量 (max_len, hashmap)
            # i.e. 把窗口末端元素加入哈希表，使其频率加1，并且更新最大长度
            hashmap[s[end]] = hashmap.get(s[end], 0) + 1
            if len(hashmap) == end - start + 1:
                max_len = max(max_len, end - start + 1)
            
            # Step 4: 
            # 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 当窗口长度大于哈希表长度时候 (说明存在重复元素)，窗口不合法
            # 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)
            while end - start + 1 > len(hashmap):
                head = s[start]
                hashmap[head] -= 1
                if hashmap[head] == 0:
                    del hashmap[head]
                start += 1
        # Step 5: 返回答案 (最大长度)
        return max_len
```

**另一种比较挫的写法：**
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 如果是目标字符串长度为0，或1，直接返回长度即为答案
        if len(s) == 1 or len(s) == 0:
            return len(s)
        
        # 定义一个字典来保存窗口滑动过程中的元素及出现个数
        # 定义最大长度初始值为0
        res, max_len = {}, 0

        # 固定窗口左侧索引start，滑动右侧的索引end
        for start in range(len(s)):
            res[s[start]] = res.get(s[start], 0) + 1
            for end in range(start+1, len(s)):
                # 右侧索引每滑动一次，先判断滑动到的元素是否已经存在在res中了，如果存在则计算最大长度并将res置为0
                if res.get(s[end]) == 1:
                    max_len = max(max_len, len(res))
                    res = {}
                    break
                else:   # 否则将元素加入res
                    res[s[end]] = res.get(s[end], 0) + 1
                    continue
        # 这里是所有的窗口滑动完成后，最后计算一次最大值
        max_len = max(max_len, len(res))
        return max_len
```